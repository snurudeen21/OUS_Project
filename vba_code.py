from scipy.interpolate import PchipInterpolator
import numpy as np
import matplotlib.pyplot as plt

# Original data
x = np.array([
    883.096956673858, 896.714870819744, 903.477160451193, 907.706106994277,
    910.670321154375, 912.896258235772, 914.647054978537, 916.070824956113,
    917.258167389847, 918.268029159256, 919.140638426821, 919.904514272702,
    920.580513545315, 921.184289696064, 921.7278511824, 922.220584889043,
    922.669948902167, 923.081953901838, 923.461505402384, 923.81265201059,
    924.138768755877, 924.442694652154, 924.726837409986, 924.993254184952,
    925.243714585219, 925.479750368185, 925.702695026862, 925.913715610257
])

y = np.array([
    110.369010483718, 220.738020967437, 331.107031451155, 441.476041934874,
    551.845052418592, 662.214062902311, 772.583073386029, 882.952083869747,
    993.321094353466, 1103.69010483718, 1214.0591153209, 1324.42812580462,
    1434.79713628834, 1545.16614677206, 1655.53515725578, 1765.9041677395,
    1876.27317822321, 1986.64218870693, 2097.01119919065, 2207.38020967437,
    2317.74922015809, 2428.11823064181, 2538.48724112552, 2648.85625160924,
    2759.22526209296, 2869.59427257668, 2979.9632830604, 3090.33229354412
])

# Interpolation
interpolator = PchipInterpolator(x, y)
coeffs = interpolator.c
breaks = interpolator.x

# Extract interval data
intervals = [[breaks[i], breaks[i+1]] for i in range(len(breaks) - 1)]
poly_data = [(coeffs[:, i], breaks[i]) for i in range(len(breaks) - 1)]

# Format VBA array blocks
def format_vba_array_blocks(data, block_size=10, is_coeff=False):
    blocks = []
    for i in range(0, len(data), block_size):
        chunk = data[i:i+block_size]
        if is_coeff:
            block = ", _\n        ".join(
                [f"Array({a:.6f}, {b:.6f}, {c:.6f}, {d:.6f}, {x0:.5f})"
                 for (a, b, c, d), x0 in [(c, x0) for c, x0 in chunk]]
            )
        else:
            block = ", _\n        ".join(
                [f"Array({start:.5f}, {end:.5f})" for start, end in chunk]
            )
        blocks.append(f"Array( _\n        {block})")
    return blocks

interval_blocks = format_vba_array_blocks(intervals)
coeff_blocks = format_vba_array_blocks(poly_data, is_coeff=True)

# Construct VBA code
vba_code = f'''Function EvaluatePx(x As Double) As Double
    Dim intervalsPart1 As Variant, intervalsPart2 As Variant, intervalsPart3 As Variant
    Dim coeffsPart1 As Variant, coeffsPart2 As Variant, coeffsPart3 As Variant
    Dim intervals As Variant, coeffs As Variant
    Dim i As Integer, dx As Double

    ' Define intervals
    intervalsPart1 = {interval_blocks[0]}
    intervalsPart2 = {interval_blocks[1] if len(interval_blocks) > 1 else "Array()"}
    intervalsPart3 = {interval_blocks[2] if len(interval_blocks) > 2 else "Array()"}

    intervals = JoinArrays(intervalsPart1, intervalsPart2, intervalsPart3)

    ' Define coefficients
    coeffsPart1 = {coeff_blocks[0]}
    coeffsPart2 = {coeff_blocks[1] if len(coeff_blocks) > 1 else "Array()"}
    coeffsPart3 = {coeff_blocks[2] if len(coeff_blocks) > 2 else "Array()"}

    coeffs = JoinArrays(coeffsPart1, coeffsPart2, coeffsPart3)

    ' Evaluate x using corresponding interval and polynomial
    For i = 0 To UBound(intervals)
        If x >= intervals(i)(0) And x <= intervals(i)(1) Then
            dx = x - coeffs(i)(4)
            EvaluatePx = coeffs(i)(0) * dx ^ 3 + coeffs(i)(1) * dx ^ 2 + coeffs(i)(2) * dx + coeffs(i)(3)
            Exit Function
        End If
    Next i

    ' If x is not in any interval, return error
    EvaluatePx = CVErr(xlErrNA)
End Function

' Helper function to concatenate multiple arrays
Private Function JoinArrays(arr1 As Variant, arr2 As Variant, arr3 As Variant) As Variant
    Dim result() As Variant
    Dim i As Long, totalLen As Long
    totalLen = UBound(arr1) + 1 + UBound(arr2) + 1 + UBound(arr3) + 1
    ReDim result(0 To totalLen - 1)

    For i = 0 To UBound(arr1): result(i) = arr1(i): Next i
    For i = 0 To UBound(arr2): result(i + UBound(arr1) + 1) = arr2(i): Next i
    For i = 0 To UBound(arr3): result(i + UBound(arr1) + UBound(arr2) + 2) = arr3(i): Next i

    JoinArrays = result
End Function
'''

# Save to file
with open("EvaluatePx_AutoGenerated.txt", "w", encoding="utf-8") as f:
    f.write(vba_code)

print("✅ VBA code generated and saved as 'EvaluatePx_AutoGenerated.txt'")

# --- 1. Generate Interval Polynomial Report ---
interval_report_lines = []
for i in range(len(breaks) - 1):
    a, b, c, d = coeffs[:, i]
    x0 = breaks[i]
    x1 = breaks[i + 1]
    interval_report_lines.append(f"Interval {i}: x in [{x0:.5f}, {x1:.5f}]")
    interval_report_lines.append(
        f"  P(x) = {a:.6f}*(x - {x0:.5f})^3 + {b:.6f}*(x - {x0:.5f})^2 + {c:.6f}*(x - {x0:.5f}) + {d:.6f}"
    )
    interval_report_lines.append("")  # Blank line for readability

# Save interval expressions to text file
with open("PchipIntervalsReport.txt", "w", encoding="utf-8") as f:
    f.write("\n".join(interval_report_lines))

print("✅ Interval expressions saved to 'PchipIntervalsReport.txt'")